# ece590-project-3-arbitrage-solved
**TO GET THIS SOLUTION VISIT:** [ECE590 Project 3-Arbitrage Solved](https://www.ankitcodinghub.com/product/ece590-project-3-arbitrage-solved/)


---

ðŸ“© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
ðŸ“± **WhatsApp:** +1 419 877 7882  
ðŸ“„ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;94257&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;1&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (1 vote)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;ECE590 Project 3-Arbitrage Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (1 vote)    </div>
    </div>
<div class="page" title="Page 1">
<div class="layoutArea">
<div class="column">
&nbsp;

1 Problem Statement

You will have two primary tasks in this project:

1. Alter the function rates2mat in project3.py so that it correctly creates the adjacency matrix given the exchange rates.

2. Implement Bellman-Ford, to detect and report a negative cost cycle in the currency graph, in the function detectArbitrage from project3.py.

1.1 rates2mat

You have been provided with a placeholder code that currently just copies each element from the rates matrix directly into the returned adjacency matrix. With only a very minor modification to this single line of code, you should be able to return the adjacency matrix with the correctly weighted edges. The function math.log may be useful here.

</div>
</div>
<div class="layoutArea">
<div class="column">
1

</div>
</div>
</div>
<div class="page" title="Page 2">
<div class="layoutArea">
<div class="column">
1.2 detectArbitrage

The function detectArbitrage will comprise the bulk of your work for this project. It will output a single list of vertex ranks corresponding to the negative cost cycle. This list needs to start and end at the same rank. This function will take 3 inputs:

â€¢ adjList: the adjacency list representing the currencies graph.

â€¢ adjMat: the adjacency matrix representing the exchange rates, as generated by the

rates2mat function.

â€¢ tol: this is a value that is set at 1e-15 as default, and should not be altered.

1.2.1 Tolerance and Machine Epsilon

The value tol will be used to deal with one very important problem. Consider what happens when there is an exchange rate where 1 Yen is equal to 12 Lira. Then clearly 1 Lira is equal to 1/12 Yen. But how is this represented on the computer? This is an infinitely repeating decimal, and so we must truncate its value. But this means that, on the computer,

R(Yen,Lira) âˆ— R(Lira,Yen) Ì¸= 1 â‡’ âˆ’ log[R(Yen,Lira)] âˆ’ log[R(Lira,Yen)] Ì¸= 0,

because there will be an error in the smallest digit. We are promised one important fact about the size of this error: it is smaller than the value known as machine epsilon (the smallest representable number using the given number of bits). For pythonâ€™s float type, machine epsilon is about 2.2e-16. This means that we cannot trust any updates of a size on the order of 1e-16. Therefore, we will ignore any updates that are smaller than our tolerance value, tol=1e-15. This will change the Bellman-Ford implementation very slightly. When we make an offer during an update step, if the update is smaller than tol we ignore it. So, we originally had the code:

<pre>            # Check each neighbor of u.
            # Update predictions and previous vertex.
            for neigh of u:
</pre>
<pre>                # Only update if the new value is better!
                if neigh.dist &gt; u.dist + length(u, neigh):
                    neigh.dist = u.dist + length(u, neigh)
</pre>
<pre>                    neigh.prev = u
</pre>
But now we will have the code:

<pre>            # Check each neighbor of u.
            # Update predictions and previous vertex.
            for neigh of u:
</pre>
<pre>                # Only update if the new value is better!
                if neigh.dist &gt; u.dist + length(u, neigh) + tol:
</pre>
<pre>                    neigh.dist = u.dist + length(u, neigh)
                    neigh.prev = u
</pre>
Your implementation of the Bellman-Ford algorithm will have to include this change. 2

</div>
</div>
</div>
<div class="page" title="Page 3">
<div class="layoutArea">
<div class="column">
1.2.2 Tasks for detectArbitrage

Your implementation of detectArbitrage will have to perform 4 major tasks:

<ol>
<li>Perform the |V | âˆ’ 1 iterations of Bellman-Ford, taking the tol value into account.</li>
<li>Perform the extra iteration and track changes in the vertex.dist values.</li>
<li>Choose a single vertex that had a change and follow its path backwards (using the vertex.prev values) until you find a cycle. Note that this cycle does not necessarily include the changed vertex you started with.</li>
<li>Once you have this path, remove any vertices that are not part of the cycle, and make sure that the list is in the correct order (hint: you traced the path backwards). This cycle will be your return value.</li>
</ol>
Note: this process does not guarantee that you will find the best negative cost cycle to choose. However, I am only asking that you find any arbitrage opportunity. You do not need to find the best arbitrage opportunity.

2 Provided Code

To aid you in these tasks, you have been provided with several fully functioning classes and functions for creating and testing the exchange rates.

2.1 Vertex Class (p3vertex.py)

The first of the fully functioning classes is the Vertex class. This class has 4 class attributes:

â€¢ rank: the rank (label) of the given vertex â€¢ neigh: the list of the neighboring vertices â€¢ dist: the distance from the start vertex

â€¢ prev: the previous vertex in the path

Along with these are three implemented member functions:

â€¢ init : this is the constructor function for the Vertex class. It requires an input rank for the vertex, and sets all of the attributes to have reasonable starting values. You will create a new Vertex with a call: v = Vertex(rank).

</div>
</div>
<div class="layoutArea">
<div class="column">
â€¢ â€¢

</div>
<div class="column">
repr : this function is called whenever a Vertex is printed, i.e. when the call print(v) is made. It simply prints the rank of the vertex.

isEqual: this takes in a second Vertex as an input, and compares the rank of the two vertices, returning True if they are equal rank (i.e., if they had the same label). This function can be called using: v.isEqual(u).

</div>
</div>
<div class="layoutArea">
<div class="column">
3

</div>
</div>
</div>
<div class="page" title="Page 4">
<div class="layoutArea">
<div class="column">
2.2 Currencies Class (p3currencies.py)

You have also been provided with a fully functioning Currencies class with 5 class attributes:

<ul>
<li>rates: a 2D array representing the exchange rates</li>
<li>currs: a list of the currency names as strings</li>
<li>adjList: the adjacency list of Vertex objects</li>
<li>adjMat: the adjacency matrix (stored as a 2D list)</li>
<li>negCyc: what will ultimately contain the negative cost cycle, stored as a list of ranks (not a list of vertices)
The Currencies class has 6 member functions:
</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
â€¢

â€¢ â€¢ â€¢ â€¢ â€¢

</div>
<div class="column">
init : this is the constructor for the Currencies class. It has one optional input: the exchangeNum which selects which set of exchange rates to use (options: 0,1,2,3 â€“ default: 0). This initialization function correctly creates the adjacency list. The negCyc attribute is initialized as an empty list. A new Currencies object can be created with the call c = Currencies(exchangeNum).

NOTE: the adjacency matrix is created using the rates2mat function. You will have to correctly implement this function (described above).

repr : this function is called when a Currencies object is printed. It will simply print all of the exchange rates.

printList: this function can be used to aid with debugging. It prints the adjacency list in a more readable format.

printMat: this function can be used to aid with debugging. It prints the adjacency matrix in a more readable format.

printArb: this function is used to print the currencies listed in the negative cycle stored in negCyc.

arbitrage: this function calls the function detectArbitrage on the Currencies to obtain the potential negative cost cycle. You will be responsible for implementing the detectArbitrage function (described above). It will then check to ensure that the reported arbitrage (if one was reported) was successful: that it was a cycle where arbitrage occurred. If the arbitrage was successful, it will report the monetary gain per unit input.

</div>
</div>
<div class="layoutArea">
<div class="column">
4

</div>
</div>
</div>
<div class="page" title="Page 5">
<div class="layoutArea">
<div class="column">
2.3 getRates and testRates

You have also been provided with two functions that create the Currencies graph (ad- jacency list and matrix) and test your code. The function getRates can be found in p3currencies.py, while testRates is in p3tests.py.

â€¢ getRates: takes in 0, 1, 2, or 3 and outputs the exchange rates for each scenario:

<ol start="0">
<li>The small arbitrage example from class.</li>
<li>A set of actual exchange rates between 14 currencies as of 11/12/18.
EUR = Euro, GBP = British Pound, CHF = Swiss Franc, USD = US Dollar, AUD = Australian Dollar, CAD = Canadian Dollar, HKD = Hong Kong Dollar, INR = Indian Rupee, JPY = Japanese Yen, SAR = Saudi Riyal,

SGD = Singapore Dollar, ZAR = South African Rand, SEK = Swedish Krona, AED = U.A.E. Dirham
</li>
<li>The same set of exchange rates, but with the US Dollar underpriced with respect to the British Pound.</li>
<li>The same set of exchange rates, but with the US Dollar underpriced with respect to the British Pound, the Japanese Yen overpriced with respect to the Indian Rupee, and the Saudi Riyal overpriced with respect to the Hong Kong Dollar.</li>
</ol>
â€¢ testRates: this function will test your code on the entire set of exchange rates. 3 Submission

You must submit your project3.py code online on Sakai. If you worked with a partner, only submit one version of your completed project and indicate clearly the names and NetIDs of both partners.

4 Pair Programming

You are allowed to work in pairs for this project. If you elect to work with a partner:

<ul>
<li>You should submit only one version of your final code. Have one partner upload the code on their Sakai site. Make sure that both partnerâ€™s names are clearly indicated at the top of the code.</li>
<li>When work is being done on this project, both partners are required to be physically present at the machine in question, with one partner typing (â€˜drivingâ€™) and the other partner watching (â€˜navigatingâ€™).</li>
<li>You should split your time equally between driving and navigating to ensure that both partners spend time coding.</li>
<li>You are allowed to discuss this project with other students in the class, but the code you submit must be written by you and your partner alone.</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
5

</div>
</div>
</div>
<div class="page" title="Page 6">
<div class="layoutArea">
<div class="column">
5 Style Points

Part of your grade for this project will be â€˜style pointsâ€™. The idea here is that the code you turn in must be well commented and readable. A reasonable user aught to be able to read through your provided code and be able to understand what it is you have done, and how your functions work. This means that a grader should be able to read over your code and tell that your algorithms are implemented correctly.

The guidelines for these â€˜style pointsâ€™:

<ul>
<li>Your program file should have a header stating the name of the program, the author(s), and the date.</li>
<li>All functions need a comment stating: the name of the function, what the function does, what the inputs are, and what the outputs are.</li>
<li>Every major block of code should have a comment explaining what the block of code is doing. This need not be every line, and it is left to your discretion to determine how frequently you place these comments. However, you should have enough comments to clearly explain the behavior of your code.</li>
<li>Please limit yourself to 80 characters in a line of code. In python, you can use the symbol \ to indicate a line break/continuation.</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
6

</div>
</div>
</div>
